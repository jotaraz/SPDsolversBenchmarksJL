using SciMLBase
using LinearSolve
using LinearAlgebra
using SparseArrays
using ExtendableSparse
using AMGCLWrap
using ILUZero: ilu0
using IncompleteLU
using AlgebraicMultigrid: smoothed_aggregation, aspreconditioner, ruge_stuben

using Gmsh: gmsh
using ExtendableGrids
using VoronoiFVM

"""
Use the function 'dobm(ids, matgens, matinps, num_sam, k; direcend="07")' (do benchmark) to solve linear systems of equations and save the benchmark data.
- The matrices are generated by the elements from 'matgens' (matrix generators) with the 'matinps' (matrix inputs, e.g. size)
- The algorithms are 'all_algs[ids]' (e.g. all_algs[1] is CG without a preconditioner and all_algs[13] is Cholesky)
- Each system of linear equations is solved 'num_sam' times.
- Everything is repeated 'k' times.
- Because of direcend="07", the data is saved in a file which is in the directory "LAbenchmarks_07" (which must exist, when the code is run). 
  This is helpful if you have data from different computers.

Example for matrix generators with only one input:
'dobm([1,2,3], [sprand_spd, fdmatrix2], [1000, 10000], 3, 5)'
- This will use the solvers CG, CG with ILUZero and CG with ILUT(0.1)
- The matrices are a random SPD matrix with 4 non-zero entries per row and a 2D Finite Difference matrix.
- Both matrix generators are used with 1000 and 10000 once.
- To get more accurate timings, the measurement is repeated (3 times immediately, and then 5 times looped over all)

Example for multiple inputs:
'dobm([1,2,3], [inhomo_square], [(0.1, 0.1), (0.05, 0.1)], 3, 5)'
- Here the matrix is a Finite Volume matrix from an inhomogenous mesh with inputs:
	- refinement 0.1 in 3 corners and 0.1*0.1 in the 4th corner 
	- refinement 0.05 in 3 corners and 0.1*0.05 in the 4th corner

See below for the code and more.

"""

# Function wrappers / misc

function incLU(A, tau)
	IncompleteLU.ilu(A, τ=tau)
end

function AMGCLWrapAMGSolverCG()
	return AMGCLWrap.AMGSolverAlgorithm(;solver=AMGCLWrap.CGSolver())
end

# Matrix generators
## Finite-Difference

function sp_ident(n)
	colptr = collect(range(1,n+1))
	rowval = collect(range(1,n))
	nzval = ones(n)
	return SparseMatrixCSC{Float64,Int64}(n, n, colptr, rowval, nzval)
end

A ⊕ B = kron(I(size(B, 1)), A) + kron(B, I(size(A, 1)))

function lattice(n; Tv = Float64)
    d = fill(2 * one(Tv), n)
    d[1] = one(Tv)
    d[end] = one(Tv)
    spdiagm(1 => -ones(Tv, n - 1), 0 => d, -1 => -ones(Tv, n - 1))
end

lattice(L...; Tv = Float64) = lattice(L[1]; Tv) ⊕ lattice(L[2:end]...; Tv)

function fdmatrix(N; dim = 2, Tv = Float64, δ = 1.0e-2)
    n = N^(1 / dim) |> ceil |> Int
    lattice([n for i in 1:dim]...; Tv) + Tv(δ) * I

end

function fdmatrix1(N;Tv = Float64, δ = 1.0e-2)
	fdmatrix(N; dim=1)
end

function fdmatrix2(N;Tv = Float64, δ = 1.0e-2)
	fdmatrix(N; dim=2)
end

function fdmatrix3(N;Tv = Float64, δ = 1.0e-2)
	fdmatrix(N; dim=3)
end

## Random SPD with fixed number of non-zero entries per row

function sprand_spd!(A; nnzrow=4, ident_fac=1.0, remain_fac=1.0)
	A = sprand_sdd!(A; nnzrow)*remain_fac
	A = ident_fac*sp_ident(size(A,1)) + A+A'
end

function sprand_spd(n; nnzrow=4, ident_fac=1.0, remain_fac=1.0)
	A = spzeros(n,n)
	A = sprand_spd!(A; nnzrow, ident_fac, remain_fac)
end

function sprand_spd10(n)
	sprand_spd(n; nnzrow=10)
end

## Voronoi stuff

function g!(f, u, edge)
    f[1] = u[1, 1] - u[1, 2]
end

function square(lc, lcfac)
	gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 0)
    gmsh.model.add("t1")

    gmsh.model.geo.addPoint(0.0, 0.0, 0, lc, 1)
    gmsh.model.geo.addPoint(1.0, 0.0, 0, lc, 2)
    gmsh.model.geo.addPoint(1.0, 1.0, 0, lc, 3)
    gmsh.model.geo.addPoint(0.0, 1.0, 0, lc*lcfac, 4)

	gmsh.model.geo.addLine(1, 2, 1)
    gmsh.model.geo.addLine(2, 3, 2)
    gmsh.model.geo.addLine(3, 4, 3)
    gmsh.model.geo.addLine(4, 1, 4)

    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], 1)
    gmsh.model.geo.addPlaneSurface([1], 1)

    gmsh.model.geo.synchronize()
	gmsh.model.mesh.generate(2)
    grid = ExtendableGrids.simplexgrid_from_gmsh(gmsh.model; Tc=Float64)

    gmsh.clear()
    gmsh.finalize()
	return grid
end

function cube(lc, lcfac)
	gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 0)
    gmsh.model.add("t1")

    gmsh.model.geo.addPoint(0.0, 0.0, 0, lc, 1)
    gmsh.model.geo.addPoint(1.0, 0.0, 0, lc, 2)
    gmsh.model.geo.addPoint(1.0, 1.0, 0, lc, 3)
    gmsh.model.geo.addPoint(0.0, 1.0, 0, lc*lcfac, 4)
	gmsh.model.geo.addPoint(0.0, 0.0, 1, lc, 5)
    gmsh.model.geo.addPoint(1.0, 0.0, 1, lc, 6)
    gmsh.model.geo.addPoint(1.0, 1.0, 1, lc, 7)
    gmsh.model.geo.addPoint(0.0, 1.0, 1, lc, 8)

	gmsh.model.geo.addLine(1, 2, 1)
    gmsh.model.geo.addLine(2, 3, 2)
    gmsh.model.geo.addLine(3, 4, 3)
    gmsh.model.geo.addLine(4, 1, 4)
	
	gmsh.model.geo.addLine(5, 6, 5)
    gmsh.model.geo.addLine(6, 7, 6)
    gmsh.model.geo.addLine(7, 8, 7)
    gmsh.model.geo.addLine(8, 5, 8)

	
	gmsh.model.geo.addLine(1, 5, 9)
    gmsh.model.geo.addLine(2, 6, 10)
    gmsh.model.geo.addLine(3, 7, 11)
    gmsh.model.geo.addLine(4, 8, 12)
	
    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], 1)
	gmsh.model.geo.addCurveLoop([5, 6, 7, 8], 2)
	gmsh.model.geo.addCurveLoop([1,10, -5, -9], 3)
    gmsh.model.geo.addCurveLoop([2,11, -6,-10], 4)
	gmsh.model.geo.addCurveLoop([3,12, -7,-11], 5)
	gmsh.model.geo.addCurveLoop([4, 9, -8,-12], 6)
    
	gmsh.model.geo.addPlaneSurface([1], 1)
	gmsh.model.geo.addPlaneSurface([2], 2)
	gmsh.model.geo.addPlaneSurface([3], 3)
	gmsh.model.geo.addPlaneSurface([4], 4)
	gmsh.model.geo.addPlaneSurface([5], 5)
	gmsh.model.geo.addPlaneSurface([6], 6)

	
	gmsh.model.geo.addSurfaceLoop([1,2,3,4,5,6], 1)
	gmsh.model.geo.addVolume([1], 1)

    gmsh.model.geo.synchronize()
	gmsh.model.mesh.generate(3)
    grid = ExtendableGrids.simplexgrid_from_gmsh(gmsh.model; Tc=Float64)

    gmsh.clear()
    gmsh.finalize()
	return grid
end

function inhomo_square(lc, lcfac) #lc, lcfac)
	#lc, lcfac = lclcfac
	grid = square(lc, lcfac)
	
	nspecies = 1
    ispec = 1
    physics = VoronoiFVM.Physics(; flux = g!)
    sys = VoronoiFVM.System(grid, physics; is_linear = true, assembly = :edgewise)
    enable_species!(sys, ispec, [1])
    #boundary_dirichlet!(sys, ispec, 1, 0.0)
    #boundary_dirichlet!(sys, ispec, 3, 1.0)
    solution = solve(sys; inival = 0)
	n = size(sys.matrix,1)
	ExtendableGrids.SparseMatrixCSC(sys.matrix)+sp_ident(n)*0.01
end

function inhomo_cube(lc, lcfac) #lc, lcfac)
	#lc, lcfac = lclcfac
	grid = cube(lc, lcfac)
	
	nspecies = 1
    ispec = 1
    physics = VoronoiFVM.Physics(; flux = g!)
    sys = VoronoiFVM.System(grid, physics; is_linear = true, assembly = :edgewise)
    enable_species!(sys, ispec, [1])
    #boundary_dirichlet!(sys, ispec, 1, 0.0)
    #boundary_dirichlet!(sys, ispec, 3, 1.0)
    solution = solve(sys; inival = 0)
	n = size(sys.matrix,1)
	ExtendableGrids.SparseMatrixCSC(sys.matrix)+sp_ident(n)*0.01
end


# benchmark fcts

function time_and_solve(A, x01, x02, alg_plus::Dict; doallocs=false) #, precon=0, preconwrap=identtity)
	b1 = A*x01
	b2 = A*x02
	mode = get(alg_plus, "mode", 1)
	blocksize = get(alg_plus, "bsize", 1)
	solver = get(alg_plus, "solver", AMGCLWrap.BICGStabSolver())
	relax = get(alg_plus, "relax", AMGCLWrap.SPAI0Relaxation())
	precond = get(alg_plus, "precond", AMGCLWrap.ILU0Relaxation())
	coarsening = get(alg_plus, "coarse", AMGCLWrap.SmoothedAggregationCoarsening())
	param = get(alg_plus, "param", nothing)
	tprecon = 0
	aprecon = 0
	if mode == 1 #LinearSolve
		alg = get(alg_plus, "algo", KrylovJL_GMRES())
		pr = LinearProblem(A,b1)
		ls = init(pr, alg)
		
		
		if haskey(alg_plus, "precon")
			tprecon = @elapsed begin
				if haskey(alg_plus, "preconwrap")
					if haskey(alg_plus, "precon_arg")
						pl = alg_plus["preconwrap"](alg_plus["precon"](A, alg_plus["precon_arg"]))
					else
						pl = alg_plus["preconwrap"](alg_plus["precon"](A))
					end
				else
					if haskey(alg_plus, "precon_arg")
						pl = alg_plus["precon"](A, alg_plus["precon_arg"])
					else
						pl = alg_plus["precon"](A)
					end
				end
			end
			ls = init(pr, alg, Pl=pl)
		end
		ls.b = b1
		t1 = @elapsed (s1 = solve!(ls))
		d1 = maximum(abs.(s1.u-x01))
		ls.b = b2
		t2 = @elapsed (s2 = solve!(ls))
		d2 = maximum(abs.(s2.u-x02))
		
		if doallocs		
			ls = init(pr, alg)
			if haskey(alg_plus, "precon")
				aprecon = @allocated begin
					if haskey(alg_plus, "preconwrap")
						if haskey(alg_plus, "precon_arg")
							pl = alg_plus["preconwrap"](alg_plus["precon"](A, alg_plus["precon_arg"]))
						else
							pl = alg_plus["preconwrap"](alg_plus["precon"](A))
						end
					else
						if haskey(alg_plus, "precon_arg")
							pl = alg_plus["precon"](A, alg_plus["precon_arg"])
						else
							pl = alg_plus["precon"](A)
						end
					end
				end
				ls = init(pr, alg, Pl=pl)
			end
			a1 = @allocated (s1 = solve!(ls))
			ls.b = b2
			a2 = @allocated (s2 = solve!(ls))
		end
	elseif mode == 3 #AMGSolver
		tprecon = @elapsed (amg = AMGSolver(A; param, blocksize, coarsening, relax, solver))
    	t1 = @elapsed (x1 = amg \ b1)
    	t2 = @elapsed (x2 = amg \ b2)
		d1 = maximum(abs.(x1-x01))
		d2 = maximum(abs.(x2-x02))

		if doallocs
			aprecon = @allocated (amg = AMGSolver(A; param, blocksize, coarsening, relax, solver))
	    	a1 = @allocated (x1 = amg \ b1)
	    	a2 = @allocated (x2 = amg \ b2)
		end
	elseif mode == 4 # RLXSolver
		tprecon = @elapsed (rlx = RLXSolver(A; param, blocksize, precond, solver))
	    t1 = @elapsed (x1 = rlx \ b1)
		t2 = @elapsed (x2 = rlx \ b2)
		d1 = maximum(abs.(x1-x01))
		d2 = maximum(abs.(x2-x02))
		
		if doallocs
			aprecon = @allocated (rlx = RLXSolver(A; param, blocksize, precond, solver))
		    a1 = @allocated (x1 = rlx \ b1)
			a2 = @allocated (x2 = rlx \ b2)
		end
	end

	if doallocs
		return tprecon, t1, t2, d1, d2, aprecon, a1, a2
	end
	return tprecon, t1, t2, d1, d2	
end


# naming

function alg_name(alg_plus::Dict)
	mode = get(alg_plus, "mode", 1)
	blocksize = get(alg_plus, "bsize", 1)
	solver = get(alg_plus, "solver", AMGCLWrap.BICGStabSolver())
	relax = get(alg_plus, "relax", AMGCLWrap.SPAI0Relaxation())
	precond = get(alg_plus, "precond", AMGCLWrap.ILU0Relaxation())
	coarsening = get(alg_plus, "coarse", AMGCLWrap.SmoothedAggregationCoarsening())
	param = get(alg_plus, "param", nothing)
	abstol = 
	s = ""
	
	if mode == 1 #LinearSolve
		alg = get(alg_plus, "algo", KrylovJL_GMRES())
		#pr = LinearProblem(A,b)
		s = "LinearSolve "
		if haskey(alg_plus, "precon")
			if haskey(alg_plus, "preconwrap")
				if haskey(alg_plus, "precon_arg")
					#pl = alg_plus["preconwrap"](alg_plus["precon"](A, alg_plus["precon_arg"]))
					s = s*"preconwrap "*string(alg_plus["preconwrap"])
					s = s*" precon "*string(alg_plus["precon"])
					s = s*"precon_arg "*string(alg_plus["precon_arg"])
				else
					#pl = alg_plus["preconwrap"](alg_plus["precon"](A))
					s = s*"preconwrap "*string(alg_plus["preconwrap"])
					s = s*" precon "*string(alg_plus["precon"])
				end
			else
				if haskey(alg_plus, "precon_arg")
					#pl = alg_plus["precon"](A, alg_plus["precon_arg"])
					s = s*"precon "*string(alg_plus["precon"])
					s = s*" precon_arg "*string(alg_plus["precon_arg"])
				else
					#pl = alg_plus["precon"](A)
					#s = s*"preconwrap"*string(alg_plus["preconwrap"])
					s = s*"precon "*string(alg_plus["precon"])
					#s = s*"precon_arg"*string(alg_plus["precon_arg"])
				end
			end
		end
		s = s*" alg "*alg_name_dict[alg]
	elseif mode == 2 #MUMPS
		s = "MUMPS " #s*" alg"*string(alg)
		#t = @elapsed (x = MUMPS.solve(A, b))
		#if doallocs
		#	n = @allocated (x = MUMPS.solve(A, b))
		#end
	elseif mode == 3 #AMGSolver
		s = "AMGSolver "
		s = s*" param "*string(param)
		s = s*" blocksize "*string(blocksize)
		s = s*" coarsening "*split(string(coarsening), "\"")[4]
		s = s*" relax "*split(string(relax), "\"")[4]
		s = s*" solver "*split(string(solver), "\"")[4]
		#amg = AMGSolver(A; param, blocksize, coarsening, relax, solver)
    	#t = @elapsed (x = amg \ b)
		#if doallocs
		#	n = @allocated (x = amg \ b)
		#end
	elseif mode == 4 # RLXSolver
		s = "RLXSolver"
		s = s*" param "*string(param)
		s = s*" blocksize "*string(blocksize)
		s = s*" precon "*split(string(precond), "\"")[4]
		s = s*" solver "*split(string(solver), "\"")[4]
		#rlx = RLXSolver(A; param, blocksize, precond, solver)
	    #t = @elapsed (x = rlx \ b)
		#if doallocs
		#	n = @allocated (x = rlx \ b)
		#end
	end
	return s
	
end

# ╔═╡ 2f2db633-b2fa-4d59-a8d0-305a202d25e8
function cut_alg_plus(alg_plus::Dict)
	x = []
	for key in keys(alg_plus)
		if key != "mode"
			push!(x, alg_plus[key])
		end
	end
	return x
end

# ╔═╡ 0f3ebd55-fd20-49f9-aa33-c81498a5ab34
function print_alg_plus(alg_plus)
	mode = get(alg_plus, "mode", 1)
	if mode == 1
		return cut_alg_plus(alg_plus)
	elseif mode == 2
		return "MUMPS"
	elseif mode == 3
		return "AMGSolver"
	elseif mode == 4
		return "RLXSolver"
	end
	
end


function benchmark(matrix_generator, matrix_inputs, algs_plus; doprint=false, doallocs=false, warnmin=false)
	num_alg = length(algs_plus)
	num_sam = length(matrix_inputs)

	times0 = zeros(num_alg, num_sam)
	times1 = zeros(num_alg, num_sam)
	times2 = zeros(num_alg, num_sam)
	diffs = zeros(num_alg, num_sam)
	alloc0 = zeros(num_alg, num_sam)
	alloc1 = zeros(num_alg, num_sam)
	alloc2 = zeros(num_alg, num_sam)
	for i=1:num_sam
		if doprint
			@warn i, "/", num_sam
		end
		A = matrix_generator(matrix_inputs[i]...)
		z1 = rand(size(A,1))
		z2 = rand(size(A,1))
		
		for ia=1:num_alg
			if doallocs
				t0,t1,t2,d1,d2,a0,a1,a2 = time_and_solve(A, z1, z2, algs_plus[ia]; doallocs)
				alloc0[ia,i] = a0
				alloc1[ia,i] = a1
				alloc2[ia,i] = a2
			else
				t0,t1,t2,d1,d2 = time_and_solve(A, z1, z2, algs_plus[ia])
			end
			times0[ia,i] = t0
			times1[ia,i] = t1
			times2[ia,i] = t2
			diffs[ia,i] = maximum([d1,d2])
		end
	end

		if warnmin
		for ia=1:num_alg
			@warn print_alg_plus(algs_plus[ia]), maximum(diffs[ia,:])
			@warn minimum(times0[ia,:]+times1[ia,:]), minimum(times2[ia,:])
		end
	end

	if doallocs
		return times0, times1, times2, diffs, alloc0, alloc1, alloc2
	end
	return times0, times1, times2, diffs
end

function benchmark(matrix_generator, matrix_input, num_sam::Integer, algs_plus; doprint=false, doallocs=false, warnmin=false)
	num_alg = length(algs_plus)
	#num_sam = length(matrix_inputs)

	times0 = zeros(num_alg, num_sam)
	times1 = zeros(num_alg, num_sam)
	times2 = zeros(num_alg, num_sam)
	diffs = zeros(num_alg, num_sam)
	alloc0 = zeros(num_alg, num_sam)
	alloc1 = zeros(num_alg, num_sam)
	alloc2 = zeros(num_alg, num_sam)
	A = matrix_generator(matrix_input...)
	for i=1:num_sam
		if doprint
			@warn i, "/", num_sam
		end
		#A = matrix_generator(matrix_inputs[i]...)
		z1 = rand(size(A,1))
		z2 = rand(size(A,1))
		
		for ia=1:num_alg
			if doallocs
				t0,t1,t2,d1,d2,a0,a1,a2 = time_and_solve(A, z1, z2, algs_plus[ia]; doallocs)
				alloc0[ia,i] = a0
				alloc1[ia,i] = a1
				alloc2[ia,i] = a2
			else
				t0,t1,t2,d1,d2 = time_and_solve(A, z1, z2, algs_plus[ia])
			end
			times0[ia,i] = t0
			times1[ia,i] = t1
			times2[ia,i] = t2
			diffs[ia,i] = maximum([d1,d2])
		end
	end

		if warnmin
		for ia=1:num_alg
			@warn print_alg_plus(algs_plus[ia]), maximum(diffs[ia,:])
			@warn minimum(times0[ia,:]+times1[ia,:]), minimum(times2[ia,:])
		end
	end

	if doallocs
		return times0, times1, times2, diffs, alloc0, alloc1, alloc2
	end
	return times0, times1, times2, diffs
end

# Writing to file

# ╔═╡ 8a484167-f2a1-433d-ac7c-de35ea442a8d
function writetofile(name, truens, diffs, t0, t1, t2, a0, a1, a2)
	io = open(name, "a")
	n_sam = length(truens)

	for i=1:n_sam
		write(io, "N="*string(truens[i])*" d="*string(diffs[i])*" a0="*string(a0[i])*" a1="*string(a1[i])*" a2="*string(a2[i])*" t0="*string(t0[i])*" t1="*string(t1[i])*" t2="*string(t2[i])*"\n")
	end

	close(io)
end

# ╔═╡ 96706076-bdd3-4820-9ce0-d304d824a39d
function benchmarktofile(matgen, matgeninps, alg; direc="LAbenchmarks_st_24/")
	name = direc*alg_name(alg)*"_Matrix_"*string(matgen)*".txt"
	times0, times1, times2, diffs, alloc0, alloc1, alloc2 = benchmark(matgen, matgeninps, [alg]; doprint=false, doallocs=true)
	truens = []
	for mi in matgeninps
		A = matgen(mi...)
		push!(truens, size(A,1))
	end

	writetofile(name, truens, diffs[1,:], times0[1,:], times1[1,:], times2[1,:], alloc0[1,:], alloc1[1,:], alloc2[1,:])
end

# ╔═╡ c10b8789-2233-4fae-862a-a6c6a3d06836
function benchmarktofile(matgen, matgeninp, num_sam::Integer, alg; direc="LAbenchmarks_st_24/")
	name = direc*alg_name(alg)*"_Matrix_"*string(matgen)*".txt"
	times0, times1, times2, diffs, alloc0, alloc1, alloc2 = benchmark(matgen, matgeninp, num_sam, [alg]; doprint=false, doallocs=true)
	truens = []
	truen0 = size(matgen(matgeninp...),1)
	for i=1:num_sam #mi in matgeninps
		#A = matgen(mi)
		push!(truens, truen0)
	end

	writetofile(name, truens, diffs[1,:], times0[1,:], times1[1,:], times2[1,:], alloc0[1,:], alloc1[1,:], alloc2[1,:])
end

all_algs = [
		Dict([("mode", 1), ("algo", KrylovJL_CG())]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", ilu0)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", incLU), ("precon_arg", 0.1)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", incLU), ("precon_arg", 0.2)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", incLU), ("precon_arg", 0.3)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", incLU), ("precon_arg", 0.4)]),
		Dict([("mode", 3), ("solver",AMGCLWrap.CGSolver())]),
		Dict([("mode", 3), ("solver",AMGCLWrap.CGSolver()), ("relax",AMGCLWrap.ILU0Relaxation())]),
		Dict([("mode", 4), ("solver",AMGCLWrap.CGSolver())]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", AMGCLWrap.AMGPrecon)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", smoothed_aggregation), ("preconwrap", aspreconditioner)]),
		Dict([("mode", 1), ("algo", KrylovJL_CG()), ("precon", ruge_stuben), ("preconwrap", aspreconditioner)]),
		Dict([("mode", 1), ("algo", LinearSolve.CholeskyFactorization())]),
		Dict([("mode", 1), ("algo", LinearSolve.LUFactorization())]),
		Dict([("mode", 1), ("algo", UMFPACKFactorization())]),
		Dict([("mode", 1), ("algo", SparspakFactorization())]),
		Dict([("mode", 1), ("algo", KLUFactorization())]),
		Dict([("mode", 1), ("algo", QRFactorization())]),
	]

alg_name_dict = Dict([(KrylovJL_CG(), "KrylovJL_CG"),
	(LinearSolve.LUFactorization(), "LinearSolve.LUFactorization"),
	(LinearSolve.CholeskyFactorization(), "LinearSolve.CholeskyFactorization"),
	(UMFPACKFactorization(), "UMFPACKFactorization"),
	(SparspakFactorization(), "SparspakFactorization"),
	(KLUFactorization(), "KLUFactorization"),
	(QRFactorization(), "QRFactorization"),
	#(MKLPardisoFactorize(), "MKLPardisoFactorize")
	])



"""
The following function benchmarks solving LSEs for multiple algorithms (ids, referring to all_algs), multiple matrix types (matgens) and multiple matrix inputs (matinpss).
All of this is repeated k times.
Each pair of generator and input is repeated num_sam times, computing the matrix only once (the matrices for large inhomogeneous meshes take a long time).
The data will be stored in the directory 'direc'.

Example for matrix generators with only one input:
dobm([1,2,3], [sprand_spd, fdmatrix2], [1000, 10000], 3, 5)

Example for multiple inputs:
dobm([1,2,3], [inhomo_square], [(0.1, 0.1), (0.05, 0.1)], 3, 5)
"""
function dobm(ids, matgens, matinps, num_sam, k; direcend="")
    for i=1:k
        for mi in matinps
            @warn mi
	    sleep(0.1)
            for mg in matgens
                for ai in ids
		    @warn ai
		    sleep(0.1)
                    benchmarktofile(mg, mi, num_sam, all_algs[ai]; direc="LAbenchmarks_"*direcend*"/")
                end
            end
        end
    end
end

"""
The following function benchmarks solving LSEs for multiple algorithms (ids, referring to all_algs), multiple matrix types (matgens) and multiple matrix inputs (matinpss).
All of this is repeated k times.
Each matrix is only created once (for one generator and one input). If the matrix is random, the input should be repeated.
The data will be stored in the directory 'direc'.

Example for matrix generators with only one input:
dobm([1,2,3], [sprand_spd, fdmatrix2], [1000, 1000, 10000, 10000], 5)

Example for multiple inputs:
dobm([1,2,3], [inhomo_square], [(0.1, 0.1), (0.05, 0.1)], 5)
"""
function dobm(ids, matgens, matinpss, k; direcend="")
    for i=1:k
        for mi in matinpss
            @warn mi
	    sleep(0.1)
            for mg in matgens
                for ai in ids
		    @warn ai
		    sleep(0.1)
                    benchmarktofile(mg, mi, all_algs[ai]; direc="LAbenchmarks_"*direcend*"/")
                end
            end
        end
    end
end



